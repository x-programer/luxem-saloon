"use server";

import { adminDb } from "@/lib/firebase/admin"; // Use Admin SDK for higher privs & consistent server-side access
import { revalidatePath } from "next/cache";

export type TicketCategory = "Technical Issue" | "Account" | "Billing" | "Feature Request";

export interface SupportTicketData {
    uid?: string; // Generated by Firestore
    vendorId: string;
    vendorName: string;
    vendorEmail: string;
    category: TicketCategory;
    subject: string;
    message: string;
    status: "open" | "resolved" | "in_progress";
    createdAt?: string; // ISO string for client
}

// 1. Create Ticket
export async function createSupportTicket(data: Omit<SupportTicketData, "uid" | "status" | "createdAt">) {
    try {
        const docRef = await adminDb.collection("support_tickets").add({
            ...data,
            status: "open",
            createdAt: new Date().toISOString() // Store as ISO String for easier seralization
        });

        return { success: true, id: docRef.id };
    } catch (error: any) {
        console.error("Error creating ticket:", error);
        return { success: false, error: error.message };
    }
}

// 2. Get All Tickets (Admin)
export async function getAllSupportTickets() {
    try {
        const snapshot = await adminDb.collection("support_tickets").orderBy("createdAt", "desc").get();

        const tickets = snapshot.docs.map(doc => ({
            uid: doc.id,
            ...doc.data()
        })) as SupportTicketData[];

        return { success: true, data: tickets };
    } catch (error: any) {
        console.error("Error fetching tickets:", error);
        return { success: false, error: error.message };
    }
}

// 3. Resolve Ticket
export async function resolveTicket(ticketId: string) {
    try {
        await adminDb.collection("support_tickets").doc(ticketId).update({
            status: "resolved"
        });

        revalidatePath("/admin/support");
        return { success: true };
    } catch (error: any) {
        console.error("Error resolving ticket:", error);
        return { success: false, error: error.message };
    }
}

// 4. Get Vendor Tickets
export async function getVendorTickets(vendorId: string) {
    try {
        const snapshot = await adminDb.collection("support_tickets")
            .where("vendorId", "==", vendorId)
            .get();

        const tickets = snapshot.docs.map(doc => ({
            uid: doc.id,
            ...doc.data()
        })) as SupportTicketData[];

        // Sort in memory to avoid needing a composite index
        tickets.sort((a, b) => {
            const dateA = new Date(a.createdAt || 0).getTime();
            const dateB = new Date(b.createdAt || 0).getTime();
            return dateB - dateA;
        });

        return { success: true, data: tickets };
    } catch (error: any) {
        console.error("Error fetching vendor tickets:", error);
        return { success: false, error: error.message };
    }
}

// 5. Delete Ticket
export async function deleteTicket(ticketId: string, vendorId: string) {
    try {
        const docRef = adminDb.collection("support_tickets").doc(ticketId);
        const docSnap = await docRef.get();

        if (!docSnap.exists) {
            return { success: false, error: "Ticket not found" };
        }

        const data = docSnap.data() as SupportTicketData;
        if (data.vendorId !== vendorId) {
            return { success: false, error: "Unauthorized" };
        }

        await docRef.delete();
        revalidatePath("/dashboard/support");
        return { success: true };
    } catch (error: any) {
        console.error("Error deleting ticket:", error);
        return { success: false, error: error.message };
    }
}

// 6. Update Ticket (Subject/Message)
export async function updateTicket(ticketId: string, vendorId: string, data: Partial<Pick<SupportTicketData, "subject" | "message">>) {
    try {
        const docRef = adminDb.collection("support_tickets").doc(ticketId);
        const docSnap = await docRef.get();

        if (!docSnap.exists) {
            return { success: false, error: "Ticket not found" };
        }

        const ticketData = docSnap.data() as SupportTicketData;
        if (ticketData.vendorId !== vendorId) {
            return { success: false, error: "Unauthorized" };
        }

        await docRef.update(data);
        revalidatePath("/dashboard/support");
        return { success: true };
    } catch (error: any) {
        console.error("Error updating ticket:", error);
        return { success: false, error: error.message };
    }
}
